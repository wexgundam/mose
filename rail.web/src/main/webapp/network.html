<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <style>
        .map {
            height: 400px;
            width: 100%;
            background-color: rgba(143, 184, 255, 0.5);
        }
    </style>
    <title>Railway Network</title>

    <link href="./assets/openlayers/ol.css" rel="stylesheet" type="text/css" />

    <script src="./assets/openlayers/ol.js" type="text/javascript"></script>

</head>
<body>
    <h2>My Map</h2>
    <div id="map" class="map"></div>
    <div id="mouse-position"></div>
    <script type="text/javascript">
        /**
         * 铁路线
         */
        class RailwayLine {
            constructor(options) {
                options = options || {};
                this.id = options.id;
                this.nodeIds = options.nodeIds || [];
                this.lineStrings = options.lineStrings || [];
            }

            /**
             * 获取Id
             * @returns {Array|*}
             */
            getId() {
                return this.id;
            }

            /**
             *获取经由nodeId数组（有序）
             */
            getNodeIds() {
                return this.nodeIds;
            }

            /**
             *获取给定索引的Node
             */
            getNodeId(index) {
                return this.nodeIds[index];
            }

            /**
             * 获取线路结构
             */
            getLineStrings() {
                return this.lineStrings;
            }

            /**
             * 设置线路结构
             */
            setLineStrings(lineStrings) {
                this.lineStrings = lineStrings;
            }

            /**
             * 获取给定id的Node在铁路线的索引
             */
            indexOf(nodeId) {
                for (let index = 0; index < this.nodeIds.length; index++) {
                    if (this.nodeIds[index] == nodeId) {
                        return index;
                    }
                }
                return -1;
            }

            /**
             * 判定是否与给定nodes方向一致
             */
            isIdentical(nodeAId, nodeBId) {
                let nodeAIndex = this.indexOf(nodeAId);
                let nodeBIndex = this.indexOf(nodeBId);
                return (nodeAIndex - nodeBIndex) <= 0 ? true : false;
            }

            /**
             * 是否经由给定node
             */
            isRouteOne(nodeId) {
                return this.nodeIds.indexOf(nodeId) != -1 ? true : false;
            }

            /**
             * 是否依次经由给定两个node，不考虑方向
             */
            isRouteTow(nodeAId, nodeBId) {
                let nodeAIndex = this.indexOf(nodeAId);
                let nodeBIndex = this.indexOf(nodeBId);
                return Math.abs(nodeAIndex - nodeBIndex) == 1 ? true : false;
            }

            /**
             * 更新两个node间的连线坐标
             */
            updateLineString(nodeAId, nodeBId, lineString) {
                if (!this.isRouteTow(nodeAId, nodeBId)) {
                    return;
                }
                let nodeAIndex = this.indexOf(nodeAId);
                let nodeBIndex = this.indexOf(nodeBId);
                if (nodeAIndex < nodeBIndex) {
                    this.lineStrings[nodeAIndex] = lineString;
                } else {
                    this.lineStrings[nodeBIndex] = lineString.reverse();
                }
            }
        }

        /**
         * 节点
         */
        class Node {
            constructor(options) {
                options = options || {};
                this.id = options.id;
                this.center = options.center || [];
                this.name = options.name;
                this.radius = options.radius ? options.radius : 500;
            }

            /**
             * 获取Id
             * @returns {Array|*}
             */
            getId() {
                return this.id;
            }

            /**
             * 获取坐标
             * @returns {Array|*}
             */
            getCenter() {
                return this.center;
            }

            /**
             * 设置坐标
             * @param center
             */
            setCenter(center) {
                this.center = center;
            }

            /**
             * 获取半径
             * @returns {Array|*}
             */
            getRadius() {
                return this.radius;
            }

            /**
             * 设置半径
             * @param coordinates
             */
            setRadius(radius) {
                this.radius = radius;
            }


            /**
             * 获取名称
             * @returns {Array|*}
             */
            getName() {
                return this.name;
            }

            /**
             * 设置名称
             * @param coordinates
             */
            setName(name) {
                this.name = name;
            }
        }

        /**
         * 铁路网自维护核心算法
         */
        function setRailwayLineLineStrings(railwayLine, railwayLines, nodes) {
            for (let nodeIndex = 0; nodeIndex < railwayLine.getNodeIds().length - 1; nodeIndex++) {
                let nodeAId = railwayLine.getNodeId(nodeIndex);
                let nodeBId = railwayLine.getNodeId(nodeIndex + 1);
                const routeRailwayLines = getRouteRailwayLines(railwayLines, nodeAId, nodeBId);
                const identical = routeRailwayLines[0].isIdentical(nodeAId, nodeBId);
                let nodeACenter = [];
                let nodeBCenter = [];
                if (identical) {
                    nodeACenter = nodes[nodeAId].getCenter();
                    nodeBCenter = nodes[nodeBId].getCenter();
                } else {
                    nodeACenter = nodes[nodeBId].getCenter();
                    nodeBCenter = nodes[nodeAId].getCenter();
                }
                const lineStrings = lineStringCore(nodeACenter, nodeBCenter, routeRailwayLines.length);
                for (let railwayLineIndex = 0; railwayLineIndex < routeRailwayLines.length; railwayLineIndex++) {
                    routeRailwayLines[railwayLineIndex].updateLineString(nodeAId, nodeBId,
                        lineStrings[railwayLineIndex]);
                }
            }
        }

        /**
         * 获取经由给定nodes的铁路线
         */
        function getRouteRailwayLines(railwayLines, nodeAId, nodeBId) {
            let routeRailwayLines = [];
            for (let index = 0; index < railwayLines.length; index++) {
                const railwayLine = railwayLines[index];
                if (railwayLine.isRouteTow(nodeAId, nodeBId)) {
                    routeRailwayLines.push(railwayLine);
                }
            }
            return routeRailwayLines;
        }

        /**
         *  核心算法
         *
         *  生成两个node之间的连线坐标
         *  所有连线围绕node中心平均分布
         *  nodeA、nodeB间线路条数为奇数时，nodes中心有连线
         *  nodeA、nodeB间线路条数为偶数时，nodes中心无连线
         *  多条线的连线按照nodeB围绕nodeA顺时针旋转在前的顺序排列
         *  连线间隔为10m
         *
         *  生成的结果：
         *  两个node间的连线用1个LineString数组表示
         *  每个数组代表一个LineString
         *  每个LineString包含4个point坐标
         *  LineString的第一个坐标一定是nodeA的center，最后一个坐标一定是nodeB的center
         *
         *  ***************************************************************************
         *  * 由于连线平均分布和顺序排列规则，每次调用该函数,相同节点间的连线坐标都会发生修改 *
         *  ***************************************************************************
         */
        function lineStringCore(nodeACenter, nodeBCenter, lineCount) {
            /**
             * 相同node间连线间距，默认100m
             */
            const interval = 100;

            //计算连点间距
            const distance = distanceBetween(nodeACenter, nodeBCenter);
            //根据间隔计算增量xy
            let deltaX = interval / distance * (nodeBCenter[1] - nodeACenter[1]);
            let deltaY = interval / distance * (nodeACenter[0] - nodeBCenter[0]);

            let lineStrings = [];
            for (let index = 0; index < lineCount; index++) {
                //根据连线数计算连线位置
                let location = (lineCount - 1) / 2 - index;
                //计算连线坐标
                let lineString = [nodeACenter, [nodeACenter[0] + deltaX * location, nodeACenter[1] + deltaY * location], [nodeBCenter[0] + deltaX * location, nodeBCenter[1] + deltaY * location], nodeBCenter];
                lineStrings.push(lineString);
            }
            return lineStrings;
        }

        /**
         * 计算平面连点距离
         */
        function distanceBetween(nodeACenter, nodeBCenter) {
            return Math.sqrt(Math.pow(Math.abs(nodeACenter[0] - nodeBCenter[0]), 2) + Math.pow(
                    Math.abs(nodeACenter[1] - nodeBCenter[1]), 2));
        }

        //中国的中心和东西南北经纬度范围
        //        let mapCenter = ol.proj.fromLonLat([108.55, 34.32]);
        //        let mapSouthwestExtent = ol.proj.fromLonLat([70, 0]);
        //        let mapNortheastExtent = ol.proj.fromLonLat([140, 55]);
        //测试
        let mapCenter = [0, 0];
        let mapSouthwestExtent = [-3000000, -3000000];
        let mapNortheastExtent = [3000000, 3000000];
        let features = [];
        let nodes = [];

        //node
        let nodeA = new Node({
            id: 0,
            center: [0, 0],
            radius: 500,
            name: "A"
        });
        nodes.push(nodeA);
        let nodeB = new Node({
            id: 1,
            center: [-3000, -3000],
            radius: 600,
            name: "B"
        });
        nodes.push(nodeB);
        let nodeC = new Node({
            id: 2,
            center: [3000, -3000],
            name: "C"
        });
        nodes.push(nodeC);
        let nodeD = new Node({
            id: 3,
            center: [3000, 3000],
            radius: 800,
            name: "D"
        });
        nodes.push(nodeD);

        //铁路线
        let railwayLines = [];
        let railwayLineA = new RailwayLine({
            id: 0,
            nodeIds: [0, 1, 2, 3],
        });
        railwayLines.push(railwayLineA);
        let railwayLineB = new RailwayLine({
            id: 1,
            nodeIds: [1, 2, 3],
        });
        railwayLines.push(railwayLineB);
        let railwayLineC = new RailwayLine({
            id: 2,
            nodeIds: [3, 2, 1, 0],
        });
        railwayLines.push(railwayLineC);
        let railwayLineD = new RailwayLine({
            id: 3,
            nodeIds: [3, 2, 0],
        });
        railwayLines.push(railwayLineD);

        for (let index = 0; index < railwayLines.length; index++) {
            const railwayLine = railwayLines[index];
            setRailwayLineLineStrings(railwayLine, railwayLines, nodes);
        }

        /**
         * 创建Node Feature
         */
        function toNodeFeature(node) {
            let feature = new ol.Feature({
                geometry: new ol.geom.Circle(node.getCenter(), node.getRadius()),
            });
            feature.setStyle(new ol.style.Style({
                stroke: new ol.style.Stroke({
                    color: randomRgba(),
                    width: 1,
                }),
                fill: new ol.style.Fill({
                    color: 'rgba(255,255,255,0.5)'
                }),
                text: new ol.style.Text({text: node.getName()}),
            }));
            return feature;
        }

        /**
         * 创建铁路线Feature
         */
        function toRailwayLineFeature(railwayLine) {
            let feature = new ol.Feature({
                geometry: new ol.geom.MultiLineString(railwayLine.getLineStrings()),
            });
            feature.setStyle(new ol.style.Style({
                stroke: new ol.style.Stroke({
                    color: randomRgba(),
                    width: 1,
                }),
            }));
            return feature;
        }

        /**
         * 随机生成颜色
         */
        function randomRgba() {
            return 'rgba(' + 255 * Math.random() + ',' + 255 * Math.random() + ',' + 255 * Math.random() + ',' + 1 + ')';
        }

        //生成Node feature
        for (let index = 0; index < nodes.length; index++) {
            const node = nodes[index];
            const feature = toNodeFeature(node);
            features.push(feature);
        }
        //生成RailwayLine feature
        for (let index = 0; index < railwayLines.length; index++) {
            const railwayLine = railwayLines[index];
            const feature = toRailwayLineFeature(railwayLine);
            //第一条线标红色
            if (index == 0) {
                feature.setStyle(new ol.style.Style({
                    stroke: new ol.style.Stroke({
                        color: 'red',
                        width: 1,
                    }),
                }));
            }
            features.push(feature);
        }

        let vectorLayer = new ol.layer.Vector({
            source: new ol.source.Vector({
                features: features,
            }),
        });

        //获取鼠标位置的坐标
        const mousePositionControl = new ol.control.MousePosition({
            coordinateFormat: ol.coordinate.createStringXY(4),
            // comment the following two lines to have the mouse position
            // be placed within the map.
            className: 'custom-mouse-position',
            target: document.getElementById('mouse-position'),
        });


        var map = new ol.Map({
            target: 'map',
            layers: [
                new ol.layer.Tile({
                    source: new ol.source.OSM()
                }),
                vectorLayer
            ],
            view: new ol.View({
                center: mapCenter,
                extent: [mapSouthwestExtent[0], mapSouthwestExtent[1], mapNortheastExtent[0], mapNortheastExtent[1]],
                zoom: 13,
                minZoom: 1
            }),
            controls: ol.control.defaults().extend([mousePositionControl])
        });
    </script>
</body>
</html>